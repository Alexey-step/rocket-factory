// =============================================================================
// PLATFORM METRICS - ИНИЦИАЛИЗАЦИЯ OPENTELEMETRY METRICS PROVIDER
// =============================================================================
//
// Этот пакет реализует инициализацию системы сбора метрик на основе OpenTelemetry.
// Он является платформенным модулем, который настраивает инфраструктуру для
// отправки метрик из приложения в коллектор OpenTelemetry.
//
// АРХИТЕКТУРА СБОРА МЕТРИК:
//
// # Application → MeterProvider → Reader → Exporter → OTLP Collector → Prometheus
//
// Компоненты:
// 1. MeterProvider - центральный объект для управления метриками
// 2. Reader - читает метрики из приложения и агрегирует их
// 3. Exporter - отправляет метрики во внешние системы
// 4. OTLP Collector - принимает метрики и пересылает в Prometheus
//
// МОДЕЛЬ ОТПРАВКИ МЕТРИК:
//
// Push Model (используется здесь):
// - Приложение активно отправляет метрики в коллектор
// - Периодическая отправка (например, каждые 10 секунд)
// - Не требует открытия портов на приложении
//
// Pull Model (альтернатива):
// - Prometheus scraping endpoints (/metrics)
// - Коллектор опрашивает приложение
package metrics

import (
	"context"
	"time"

	"github.com/pkg/errors"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
	"go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
)

const (
	// defaultTimeout - таймаут для отправки батча метрик в коллектор
	// Важно: не должен быть слишком большим, чтобы не блокировать приложение
	// Обычно 5-10 секунд достаточно для большинства случаев
	defaultTimeout = 5 * time.Second
)

// =============================================================================
// ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ - SINGLETON PATTERN
// =============================================================================
//
// Используем глобальные переменные для MeterProvider и Exporter, потому что:
// 1. OpenTelemetry рекомендует один MeterProvider на приложение
// 2. Все части приложения должны использовать один экспортер
// 3. Упрощает dependency injection в больших приложениях
// 4. Позволяет корректно закрыть ресурсы при shutdown
//
// Альтернативы:
// - Dependency Injection Container (wire, dig)
// - Context-based передача зависимостей
// - Service Locator pattern
var (
	// exporter - компонент для отправки метрик по протоколу OTLP (OpenTelemetry Protocol)
	// OTLP - стандартный протокол для передачи телеметрии между компонентами
	// Поддерживает HTTP и gRPC транспорты (используем gRPC для лучшей производительности)
	exporter *otlpmetricgrpc.Exporter

	// meterProvider - центральный объект OpenTelemetry для управления метриками
	// Отвечает за:
	// - Создание Meter'ов для разных компонентов приложения
	// - Агрегацию метрик (суммирование, подсчет percentile)
	// - Периодическую отправку метрик через Reader
	// - Управление жизненным циклом метрик
	meterProvider *metric.MeterProvider
)

// =============================================================================
// CONFIGURATION INTERFACE - DEPENDENCY INVERSION PRINCIPLE
// =============================================================================
//
// Config определяет абстракцию для конфигурации метрик.
// Это применение принципа инверсии зависимостей:
// - Платформенный модуль не зависит от конкретной реализации конфигурации
// - Позволяет использовать разные источники конфигурации (файлы, переменные окружения)
// - Упрощает тестирование (можно создать mock конфигурацию)
type Config interface {
	// CollectorEndpoint возвращает адрес OTLP коллектора
	// Обычно: "localhost:4317" (gRPC) или "localhost:4318" (HTTP)
	CollectorEndpoint() string

	// CollectorInterval возвращает интервал отправки метрик
	// Компромисс между актуальностью метрик и нагрузкой на сеть
	// Обычно: 10-60 секунд в зависимости от требований
	CollectorInterval() time.Duration
	CollectorServiceName() string
	CollectorServiceVersion() string
	CollectorEnvironment() string
}

// =============================================================================
// ИНИЦИАЛИЗАЦИЯ МЕТРИК - BOOTSTRAP PROCESS
// =============================================================================

// InitProvider инициализирует глобальный провайдер метрик OpenTelemetry
//
// Этот метод выполняет следующие шаги:
// 1. Создает OTLP экспортер для отправки метрик в коллектор
// 2. Настраивает MeterProvider с периодическим чтением метрик
// 3. Устанавливает глобальный провайдер метрик для всего приложения
//
// ВАЖНО: Должен быть вызван один раз при старте приложения, до создания метрик
//
// Параметры:
// - ctx: контекст для отмены операции и таймаутов
// - cfg: конфигурация с адресом коллектора и интервалом отправки
//
// Возвращает ошибку, если не удалось подключиться к коллектору
func InitProvider(ctx context.Context, cfg Config) error {
	var err error

	// =======================================================================
	// ШАГ 1: СОЗДАНИЕ OTLP ЭКСПОРТЕРА
	// =======================================================================
	//
	// OTLP (OpenTelemetry Protocol) - стандартный протокол для телеметрии
	// Преимущества OTLP:
	// - Эффективная бинарная сериализация (protobuf)
	// - Поддержка батчинга для уменьшения нагрузки на сеть
	// - Стандартизованный формат для совместимости
	// - Встроенная поддержка сжатия и retry логики
	//
	exporter, err = otlpmetricgrpc.New(
		ctx,
		// Адрес коллектора (обычно localhost:4317 для gRPC)
		otlpmetricgrpc.WithEndpoint(cfg.CollectorEndpoint()),

		// Отключаем TLS для локальной разработки
		// В production используйте TLS и authentication
		otlpmetricgrpc.WithInsecure(),

		// Таймаут для отправки каждого батча метрик
		// Предотвращает блокировку приложения при проблемах с сетью
		otlpmetricgrpc.WithTimeout(defaultTimeout),
	)
	if err != nil {
		return errors.Wrap(err, "failed to create metrics exporter")
	}

	// 2. Создаем ресурс с метаданными о сервисе
	// Resource - это набор атрибутов, описывающих источник телеметрии
	// Эти атрибуты добавляются ко всем метрикам автоматически
	res, err := resource.New(
		ctx,
		resource.WithAttributes(
			attribute.String("service.name", cfg.CollectorServiceName()),           // Обязательный атрибут
			attribute.String("service.version", cfg.CollectorServiceVersion()),     // Версия сервиса
			attribute.String("deployment.environment", cfg.CollectorEnvironment()), // Окружение (dev/staging/prod)
		),
	)
	if err != nil {
		return errors.Wrap(err, "failed to create resource")
	}

	// =======================================================================
	// ШАГ 3: СОЗДАНИЕ METER PROVIDER
	// =======================================================================
	//
	// MeterProvider - центральный объект для управления метриками
	// Использует паттерн Builder для настройки:
	//
	// Reader отвечает за:
	// - Периодическое чтение метрик из приложения
	// - Агрегацию данных (суммирование counter'ов, вычисление percentile)
	// - Отправку батчей метрик через экспортер
	// - Управление состоянием метрик между отправками
	//
	meterProvider = metric.NewMeterProvider(
		metric.WithResource(res), // Добавляем ресурс с метаданными
		// Настраиваем периодический Reader
		metric.WithReader(
			// PeriodicReader автоматически читает и отправляет метрики
			metric.NewPeriodicReader(
				exporter, // Используем созданный OTLP экспортер
				// Интервал чтения и отправки метрик
				// Частые отправки = более актуальные метрики, но больше нагрузки
				metric.WithInterval(cfg.CollectorInterval()),
			),
		),
	)

	// =======================================================================
	// ШАГ 3: УСТАНОВКА ГЛОБАЛЬНОГО ПРОВАЙДЕРА
	// =======================================================================
	//
	// Устанавливаем созданный провайдер как глобальный
	// После этого все вызовы otel.Meter() будут использовать наш провайдер
	//
	// Глобальный провайдер vs локальный:
	// + Простота использования в любой части приложения
	// + Не нужно передавать зависимости через dependency injection
	// - Усложняет тестирование (нужно сбрасывать глобальное состояние)
	// - Может создать проблемы при модульном тестировании
	//
	otel.SetMeterProvider(meterProvider)

	return nil
}

// =============================================================================
// GETTER METHODS - ДОСТУП К ВНУТРЕННИМ КОМПОНЕНТАМ
// =============================================================================

// GetMeterProvider возвращает текущий провайдер метрик
//
// Используется для:
// - Создания дополнительных Reader'ов (например, для тестирования)
// - Получения статистики о метриках
// - Низкоуровневого доступа к функциональности провайдера
//
// В большинстве случаев лучше использовать otel.Meter() для создания метрик
func GetMeterProvider() *metric.MeterProvider {
	return meterProvider
}

// =============================================================================
// GRACEFUL SHUTDOWN - КОРРЕКТНОЕ ЗАКРЫТИЕ РЕСУРСОВ
// =============================================================================

// Shutdown корректно закрывает провайдер метрик и экспортер
//
// ВАЖНОСТЬ GRACEFUL SHUTDOWN:
// - Отправляет оставшиеся метрики перед закрытием
// - Освобождает сетевые соединения и goroutines
// - Предотвращает потерю данных при перезапуске приложения
// - Соблюдает контракт с коллектором (корректное закрытие gRPC соединения)
//
// # Должен быть вызван в defer или signal handler при завершении приложения
//
// Параметры:
// - ctx: контекст с таймаутом для graceful shutdown (обычно 5-10 секунд)
//
// Возвращает ошибку, если не удалось корректно закрыть ресурсы
func Shutdown(ctx context.Context) error {
	// Проверяем, что есть что закрывать
	if meterProvider == nil && exporter == nil {
		return nil
	}

	var err error

	// Сначала закрываем провайдер метрик
	// Это остановит отправку новых метрик и отправит оставшиеся
	if meterProvider != nil {
		err = meterProvider.Shutdown(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to shutdown meter provider")
		}
	}

	// Затем закрываем экспортер
	// Это закроет сетевые соединения и освободит ресурсы
	if exporter != nil {
		err = exporter.Shutdown(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to shutdown exporter")
		}
	}

	return nil
}
